# Зачем RoleContext в БД?

## Обзор

`RoleContext` - это отдельная таблица в базе данных, которая хранит информацию о ролях пользователей. Может показаться, что это избыточно, но на самом деле это критически важная часть архитектуры для поддержки multi-role системы.

## Основные причины хранения RoleContext в БД

### 1. Multi-Role поддержка

**Проблема:** Один пользователь может быть одновременно и кандидатом, и работодателем.

**Решение:** RoleContext позволяет одному User иметь несколько ролей:

```
User (user@example.com)
├── RoleContext 1: CANDIDATE (кандидат)
└── RoleContext 2: EMPLOYER (владелец компании)
```

**Без RoleContext:**
- Невозможно хранить несколько ролей для одного пользователя
- Пришлось бы создавать отдельные записи User для каждой роли
- Потеря связи между ролями одного человека

**С RoleContext:**
- Один User может иметь несколько RoleContext
- Все роли связаны с одним аккаунтом
- Пользователь может переключаться между ролями

### 2. Привязка к компании для EMPLOYER

**Проблема:** Работодатель всегда работает в контексте компании.

**Решение:** RoleContext хранит `companyId` для EMPLOYER ролей:

```prisma
RoleContext {
  userRole: EMPLOYER
  companyId: "company-123"  // Обязательно для EMPLOYER
  hrRoleId: "hr-admin"      // HR_ADMIN или HR
}
```

**Без RoleContext:**
- Пришлось бы хранить `companyId` в User (но User может быть и кандидатом)
- Невозможно иметь несколько EMPLOYER ролей в разных компаниях
- Сложнее управлять правами доступа

**С RoleContext:**
- Четкая привязка EMPLOYER роли к компании
- Один пользователь может быть HR в нескольких компаниях (разные RoleContext)
- Легко определить, в какой компании работает пользователь

### 3. Привязка токенов к роли

**Проблема:** Токены должны быть привязаны к конкретной роли, а не только к пользователю.

**Решение:** Token хранит `roleContextId`:

```prisma
Token {
  userId: "user-123"
  roleContextId: "role-context-456"  // CANDIDATE или EMPLOYER
  deviceId: "device-789"
}
```

**Без RoleContext:**
- Токен привязан только к User
- Непонятно, в какой роли работает пользователь
- Невозможно иметь разные токены для разных ролей на одном устройстве

**С RoleContext:**
- Токен четко привязан к роли
- JWT содержит `roleContextId` для быстрого определения роли
- Можно иметь разные токены для разных ролей на разных устройствах

### 4. Независимые сессии для разных ролей

**Сценарий:** Пользователь работает как кандидат на телефоне и как работодатель на компьютере.

**С RoleContext:**
```
Телефон:  Token (user-123, roleContext-CANDIDATE, device-phone)
Компьютер: Token (user-123, roleContext-EMPLOYER, device-pc)
```

Оба устройства работают независимо с разными ролями.

**Без RoleContext:**
- Невозможно иметь независимые сессии для разных ролей
- Пришлось бы логиниться заново при смене роли
- Потеря контекста при переключении

### 5. История и аудит

**Преимущество:** RoleContext хранит `createdAt`, что позволяет:
- Отслеживать, когда пользователь получил роль
- Аудит изменений ролей
- Понимать историю работы пользователя в системе

**Пример:**
```
RoleContext 1: CANDIDATE, createdAt: 2024-01-01
RoleContext 2: EMPLOYER, createdAt: 2024-02-15
```

Видно, что пользователь сначала был кандидатом, потом стал работодателем.

### 6. Управление правами доступа

**Преимущество:** RoleContext позволяет:
- Хранить `hrRoleId` для EMPLOYER (HR vs HR_ADMIN)
- Определять права доступа через Guards
- Проверять принадлежность к компании

**Пример проверки:**
```typescript
// Guard проверяет RoleContext
if (roleContext.userRole === UserRole.EMPLOYER) {
  if (roleContext.companyId !== requestedCompanyId) {
    throw new ForbiddenException();
  }
  if (roleContext.hrRole.name === HrRoleName.HR_ADMIN) {
    // Разрешить управление HR
  }
}
```

### 7. Каскадное удаление и целостность данных

**Преимущество:** При удалении Company все связанные RoleContext удаляются:

```prisma
company Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)
```

Это предотвращает "висячие" EMPLOYER роли после удаления компании.

## Альтернативные подходы (и почему они хуже)

### Вариант 1: Хранить роли в User

```prisma
model User {
  roles: Json  // ["CANDIDATE", "EMPLOYER"]
  companyId: String?
}
```

**Проблемы:**
- Невозможно иметь несколько EMPLOYER ролей в разных компаниях
- Сложно управлять правами (какая компания для какой роли?)
- Нет истории создания ролей
- Токены не могут быть привязаны к конкретной роли

### Вариант 2: Отдельные таблицы для каждой роли

```prisma
model Candidate {
  userId: String
}

model Employer {
  userId: String
  companyId: String
}
```

**Проблемы:**
- Дублирование данных
- Сложнее управлять связями
- Нет единой точки для управления ролями
- Сложнее переключаться между ролями

### Вариант 3: Хранить только в JWT

```typescript
// JWT содержит роли, но не хранится в БД
{
  userId: "user-123",
  roles: ["CANDIDATE", "EMPLOYER"]
}
```

**Проблемы:**
- Нет истории ролей
- Невозможно отозвать роль без инвалидации всех токенов
- Сложно управлять правами доступа
- Нет связи с компанией в токене (слишком большой payload)

## Итог

**RoleContext в БД нужен для:**

1. ✅ **Multi-role поддержка** - один пользователь, несколько ролей
2. ✅ **Привязка к компании** - EMPLOYER всегда в контексте компании
3. ✅ **Привязка токенов** - токены привязаны к конкретной роли
4. ✅ **Независимые сессии** - разные роли на разных устройствах
5. ✅ **История и аудит** - отслеживание создания ролей
6. ✅ **Управление правами** - проверка доступа через Guards
7. ✅ **Целостность данных** - каскадное удаление при удалении Company

**Без RoleContext:**
- Невозможно полноценно поддерживать multi-role
- Сложнее управлять правами доступа
- Нет истории и аудита
- Потеря гибкости архитектуры

## Ссылки

- [Концепция аутентификации](../04-authentication/concept.md) - детальное описание multi-role системы
- [Модели БД](../04-authentication/database-models.md) - структура RoleContext
- [Prisma Schema](./prisma-schema.md) - схема RoleContext в Prisma
